% LCI Documentation (greek)
% 
% Copyright (C) 2003 Kostas Hatzikokolakis
% This file is part of LCI
%
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% (at your option) any later version.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.

% THIS IS THE FIRST DOCUMENTATION FILE WRITTEN IN GREEK.
% IT IS NO LONGER MAINTAINED. PLEASE CHECK THE ENGLISH DOCUMENTATION.

\documentclass[a4paper,11pt]{article}

\usepackage[british,greek]{babel}
\usepackage[iso-8859-7]{inputenc}

\newcommand{\la}{$\lambda$}
\newcommand{\lci}{\texttt{\en{lci}}}
\newcommand{\qm}[1]{\en{``}#1\en{''}}
\newcommand{\sen}{\selectlanguage{british}}
\newcommand{\sgr}{\selectlanguage{greek}}
\newcommand{\kwd}[1]{\en{\texttt{#1}}}

\author{
	Κώστας Χατζηκοκολάκης
}
\title{
	{\large
	Αρχές Γλωσσών Προγραμματισμού \\
	Εργασία 3η \\}
	\vspace{15pt}
	Διερμηνέας για τον \la-λογισμό \\
	\vspace{15pt}
}
\date{8 Φεβρουαρίου 2003}


\newcommand{\gr}[1]{\textgreek{#1}}
\newcommand{\en}[1]{\textlatin{#1}}

\newcommand{\tab}{\makebox[.8cm]{}}

\begin{document}

\maketitle
\vspace{60pt}
%\tableofcontents


Το έγγραφο αυτό περιγραάφει την λειτουργία του προγράμματος \texttt{\en{lci}} το οποίο
είναι ένας διερμηνέας για το \la-λογισμό. Το πρόγραμμα αναπτύχθηκε στα πλαίσια του
μαθήματος Αρχές Γλωσσών Προγραμματισμού και παράγει την κανονική μορφή όρων του
\qm{καθαρού} \la-λογισμού (\en{pure lambda calculus}). Επιπλέον υποστηρίζεται ένα
σύνολο από πρόσθετες λειτουργίες οι οποίες όμως όλες υλοποιούνται μέσω του καθαρού
λογισμού.

\section{Συντακτικό}
Ο \lci{} υποστηρίζει το συντακτικό του \la-λογισμού εμπλουτισμένο με \emph{ακεραίους},
\emph{αναγνωριστικά} και \emph{τελεστές}. Η γλώσσα αυτή περιγράφεται από την ακόλουθη
γραμματική.
\begin{center}
	\en{
	\begin{tabular}{rcl}
		Term	& $\rightarrow$ & var \\
		& $|$ & ( Term Oper Term ) \\
		& $|$ & ( \la{} var . Term ) \\
		& $|$ & num \\
		& $|$ & id \\
		Oper & $\rightarrow$ & op \\
		& $|$ & $\varepsilon$
	\end{tabular}
	}
\end{center}

Για το \la{} μπορεί να χρησιμοποιηθεί το $\backslash$ ή ο ελληνικός χαρακτήρας \qm{λ}
ενώ αντί για την τελεία μπορεί να χρησιμοποιηθεί και το \sen\verb+->+\sgr.
Το \en{var} είναι μια οποιαδήποτε συμβολοσειρά που αποτελείται από λατινικούς χαρακτήρες
(πεζούς η κεφαλαίους), αριθμούς και \en{underscore} αλλά αρχίζει από πεζό χαρακτήρα
ή \en{underscore}. Το ίδιο ισχύει και για το \en{id} με τη διαφορά ότι πρέπει να αρχίζει
από κεφαλαίο χαρακτήρα. Επίσης ένα \en{id} μπορεί να εσωκλείεται σε απλά εισαγωγικά
οπότε επιτρέπει η χρήση σχεδόν όλων των χαρακτήρων.
Το \en{num} είναι μια συμβολοσειρά που αποτελείται από αριθμούς
και το \en{op} είναι μια συμβολοσειρά που αποτελείται από τους χαρακτήρες
\sen
\begin{center}
	\verb?~ ! @ $ % ^ & * / + - = < > | . , : ; ?
\end{center}
\sgr
εκτός από τους δεσμευμένους τελεστές \sen\verb+-> . = ; ?+\sgr.
Περισσότερα για τους ακεραίους, τα αναγνωριστικά και τους τελεστές θα αναφερθούν σε
επόμενες ενότητες. Τέλος, οι παρενθέσεις μπορούν να αποφεύγονται με βάση τους παρακάτω
κανόνες:
\begin{itemize}
	\item Οι εξωτερικές παρενθέσεις δεν γράφονται
	\item Η εφαρμογή είναι αριστερά προσεταιριστική
	\item Οι αφαιρέσεις εκτείνονται όσο περισσότερο γίνεται
	\item Η συντακτική αναγνώριση των τελεστών γίνεται με βάση την προτεραιότητα
	και την προσεταιριστικότητά τους. Περισσότερες πληροφορίες υπάρχουν στην
	αντίστοιχη ενότητα
\end{itemize}

\section{Βασική λειτουργία}
Η βασική λειτουργία του προγράμματος είναι να δέχεται από τον χρήστη \la-όρους, να
παράγει την κανονική μορφή τους (εκτελώντας όλες τις $\beta$ και $\eta$ μετατροπές)
και να τυπώνει τον τελικό όρο. Η εκτύπωση γίνεται με \qm{ευανάγνωστο} τρόπο, δηλαδή
εμφανίζονται μόνο οι απαραίτητες παρενθέσεις, τα \en{church numerals} εμφανίζονται
ως δεκαδικοί αριθμοί και οι λίστες με την μορφή της \en{Prolog}. Ο τρόπος εκτύπωσης
όμως μπορεί να αλλάξει θέτωντας κατάλληλες παραμέτρους, για παράδειγμα η εντολή
\sen
\begin{center}
	\verb+Set showpar on+
\end{center}
\sgr
προκαλεί την εμφάνιση όλων των παρενθέσεων κατά την εκτύπωση ενός όρου.

Οι μετατροπές γίνονται με βάση την \emph{στρατηγική της αναγωγής κανονικής σειράς}
(\en{normal order reduction strategy}), δηλαδή επιλέγεται κάθε φορά το $\beta$ ή
$\eta$-\en{redex} του οποίου το \la{} βρίσκεται αριστερότερα. Αυτό εξασφαλίζει ότι
σε πεπερασμένο χρόνο θα βρεθεί η κανονική μορφή του όρου, αν αυτή υπάρχει. Αν δεν υπάρχει
όμως, το πρόγραμμα ενδέχεται να μην τερματίσει. Οταν ολοκληρωθεί ο υπολογισμός το
πρόγραμμα τυπώνει τον αριθμό των μετατροπών που εκτελέστηκαν και τον χρόνο
χρήσης της \en{CPU}.

\section{Ακέραιοι}
O \lci{} υποστηρίζει ακεραίους κωδικοποιώντας τους κατά την συντακτική ανάλυση
σε \en{church numerals}. Έτσι ο αριθμός $n$ μετατρέπεται στον όρο
\[ c_n \equiv \lambda f.\lambda x.f^n(x) \]
Στην ουσία δηλαδή πρόκειται απλώς για μια συντακτική ευκολία. Όλες οι πράξεις
των ακεραίων έχουν υλοποιηθεί σε \la-λογισμό και χρησιμοποιούνται με τη
βοήθεια των αναγνωριστικών και των τελεστών. Το γεγονός βέβαια αυτό έχει ως
αποτέλεσμα την μείωση της απόδοσης. Έτσι για λόγους περιορισμού της στοίβας
ο μέγιστος αριθμός που μπορεί να χρησιμοποιηθεί είναι ο 9999 ενώ η ύψωση σε δύναμη
χρειάζεται υπερβολικά πολύ χρόνο, ακόμα και για μικρούς αριθμούς.

\section{Αναγνωριστικά}
Τα αναγνωριστικά επιτρέπουν την εύκολη αναπαράσταση μεγάλων \la-όρων με τη χρήση
ψευδωνύμων (\en{aliases}). Ετσι για παράδειγμα ο όρος $\lambda x.x$ μπορεί να
αντιστοιχηθεί στο ψευδώνυμο $Ι$ με αποτέλεσμα ο όρος $I\ y$ να ερμηνεύεται ως
$(\lambda x.x)\ y$. Ο ορισμός των ψεωδωνύμων πρέπει να γίνει σε κάποιο αρχείο το
οποίο διερμηνεύεται από το πρόγραμμα. Η μορφή του αρχείου περιγράφεται από την
ακόλουθη γραμματική.
\begin{center}
	\en{
	\begin{tabular}{rcl}
		CmdList & $\rightarrow$ & Cmd ; CmdList \\
		& $|$ & $\varepsilon$ \\
		Cmd & $\rightarrow$ & id = Term \\
		& $|$ & ? Term
	\end{tabular}
	}
\end{center}
Η εντολή \en{id = Term} αντιστοιχεί τον όρο \en{Term} στο αναγνωριστικό \en{id}
ενώ η εντολή \en{? Term} προκαλεί την παραγωγή της κανονικής μορφής του όρου, όπως
ακριβώς και αν αυτό δινόταν από το πληκτρολόγιο. Η επεξεργασία ενός αρχείου γίνεται
με την εντολή
\sen
\begin{center}
	\verb+Consult 'file'+
\end{center}
\sgr
ενώ κατά την εκκίνηση του προγράμματος διαβάζεται το αρχείο \kwd{.lcirc}
το οποίο πρέπει να βρίσκεται στον ίδιο κατάλογο με το πρόγραμμα. Το αρχείο αυτό περιέχει
δηλώσεις πολλών βασικών συναρτήσεων (για παράδειγμα πράξεις ακεραίων) και είναι ανάλογο με
το \kwd{prelude.hs} της \en{Haskell}.

Η αντικατάσταση ενός αναγνωριστικού με τον αντίστοιχο όρο γίνεται κατά την μετατροπή
του όρου και όχι κατά την συντακτική αναγνώριση. Έτσι η σειρά των δηλώσεων δεν έχει
σημασία ενώ αν ένα ψεωδώνυμο δεν έχει οριστεί τότε κατά την μετατροπή εμφανίζεται
μήνυμα σφάλματος. Αν κανένα ψευδώνυμο δεν χρησιμοποιεί τον εαυτό του (άμεσα ή έμμεσα)
τότε ουσιαστικά παρέχουν απλώς μια συντακτική ευκόλια καθώς αντικαθιστώντας όλα τα
ψευδώνυμα παράγουμε έναν αποδεκτό \la-όρο. Παρ' όλα
αυτά το πρόγραμμα επιτρέπει ψεωδύνυμα με κυκλικές αναφορές υλοποιώντας έτσι την
αναδρομή. Η λειτουργία αυτή περιγράφεται στην επόμενη ενότητα.

\section{Αναδρομή}
Η αναδρομή είναι βασικό προγραμματιστικό εργαλείο που παρέχεται από κάθε σοβαρή γλώσσα
προγραμματισμού. Ο \lci{} υποστηρίζει αναδρομή με δύο τρόπους: είτε μέσω
\emph{όρων απείρου μήκους} είτει μέσω \emph{τελεστών σταθερού σημείου}
(\en{fixed point combinators}). Οι δύο λειτουργίες περιγράφονται στις επόμενες
παραγράφους.

\subsection{Αναδρομή μέσω απείρων όρων}
Αν επιτρέψουμε την εμφάνιση ενός ψευδώνυμου μέσα στον εαυτό του τότε μπορούμε
να γράψουμε όρους όπους ο ακόλουθος
\[ M = \lambda x.M\ y \]
Αντικαθιστώντας το $M$ με βάση τον ορισμό παίρνουμε τον όρο $\lambda x.(\lambda x.M\ x)\ x$
και συνεχίζοντας τις αντικαταστάσεις προκύπτει ο όρος
\[ \lambda x.(\lambda x.(\lambda x.(...)\ y)\ y)\ y \]
δηλαδή ο $M$ μπορεί να θεωρηθεί σαν ένας όρος απείρου μήκους. Φυσικά δεν είναι ένας
αποδεκτός \la-όρος αλλά παρ' όλα αυτά μπορεί να φανεί χρήσιμος.

Έστω τώρα ότι ένας αυθαίρετος κλειστός όρος $M$ δηλαδή $FV(M) = \emptyset$. Εύκολα
μπορούμε να συμπεράνουμε τα ακόλουθα
\[
	\begin{array}{lcl}
		M[x:=N] & \equiv & M \\
		(\lambda y.N)[x:=M] & \equiv & \lambda y.N[x:=M] \\
		\lambda x.M\ x & \rightarrow_\eta & M
	\end{array}
\]
Δηλαδή οι αντικαταστάσεις μεταβλητών καθώς και η $\eta$-μετατροπή μπορούν να γίνουν
χωρίς να γνωρίζουμε τι περιέχει ο $M$ δηλαδή χωρίς να τον αντικαταστήσουμε. Έτσι
κατά τον υπολογισμό της κανονικής μορφής ο $Μ$ χρειάζεται να αντικατασταθεί μόνο
όταν ο τρέχον όρος είναι ένας από τους ακόλουθους:
\begin{eqnarray}
	& M\ N \\
	& M
\end{eqnarray}

Στην πρώτη περίπτωση ο $M$ μπορεί να περιέχει κάποια αφαίρεση ενώ στην δεύτερη 
ένα οποιοδήποτε \en{redex}. Αντικαθιστώντας έναν όρο μόνο όταν πραγματικά χρειάζεται είναι δυνατόν
να φτάσουμε σε κανονική μορφή χωρίς να γίνουν όλες οι αντικαταστάσεις. Για παράδειγμα
ο όρος $\lambda x.y$ δεν χρησιμοποιεί το όρισμά του έτσι η ακόλουθη μετατροπή
\[ (\lambda x.y)\ M \rightarrow_\beta y \]
απαλείφει το $M$ χωρίς να χρειαστεί ο υπολογισμός του.

Ο \lci{} ακολουθεί αυτή την λογική όσον αφορά τα ψευδώνυμα. Αντικαθιστά δηλαδή ένα
αναγνωριστικό με τον αντίστοιχο όρο μόνο όταν χρειάζεται και μόνο μία φορά. Έτσι
ακόμα και αν ένας όρος είναι αναδρομικός είναι δυνατόν να βρεθεί η κανονική μορφή
αν η αναδρομή διακόπτεται από κάποια συνθήκη. Στο \kwd{.lcirc} έχουν οριστεί
αρκετοί αναδρομικοί όροι, κύριως για λειτουργίες που αφορούν λίστες.

Η μέθοδος αυτή \qm{αλλοιώνει} τον κλασικό \la-λογισμό εισάγοντας όρους που δεν είναι
αποδεκτοί. Αξίζει όμως να σημειωθεί το εξής: έστω ότι στον όρο
$M = \lambda x.M\ x$ χρειαστεί να αντικατασταθεί το $Μ$ μόνο δύο φορές μέχρι να 
φτάσουμε σε κανονική μορφή. Αυτό σημαίνει ότι στο όρο
$ \lambda x.(\lambda x.(\lambda x.M\ y)\ y)\ y $
το $M$ δεν χρειάστηκε να υπολογιστεί. Έτσι μπορούμε να το αντικαταστήσουμε με
έναν οποιοδήποτε αποδεκτό όρο $N$ παίρνοντας τον νέο όρο
\[ Μ' = \lambda x.(\lambda x.(\lambda x.Ν\ y)\ y)\ y \]
Ο $M'$ έχει την ίδια ακριβώς συμπεριφορά με τον $M$ και επιπλέον είναι αποδεκτός.
Βέβαια σε μια άλλη περίπτωση μπορεί να χρειαζόντουσαν περισσότερες
αντικαταστάσεις δίνοντας ένα διαφορετικό $M'$. Έτσι ο $M$ μπορεί να θεωρηθεί ως μια
\qm{γεννήτρια} όρων που παράγει κάθε φορά ένα κατάλληλο $M'$.

\subsection{Αναδρομή μέσω τελεστών σταθερού σημείου}
Η αναδρομή μπορεί να υποποιηθεί και στον κλασικό \la-λογισμό με ένα ιδιαίτερα
κομψό τρόπο, χρησιμοποιώντας έναν τελεστή σταθερού σημείου. Ένα τέτοιος τελεστής $Y$
είναι ένας \la-όρος που ικανοποιεί την σχέση
\[ Y f \rightarrow f\ (Y f) \]
για κάθε όρο $f$. Έστω τώρα μια συνάρτηση $f=E$ όπου η $f$ περιέχεται στο $E$. Αρχικά
μετρέπουμε το $f$ σε μεταβλητή παίρνοντας τον μη αναδρομικό όρο $\lambda f.E$.
Τώρα εύκολα φαίνεται ότι ο όρος $Y (\lambda f.E)$ περιέχει τον εαυτό του και κάνει
ακριβώς τη δουλειά που θέλουμε.

Τα πράγματα γίνονται λίγο πιο περίπλοκα αν έχουμε το ακόλουθο σύνολο συναρτήσεων
\begin{eqnarray*}
	f_1 & = & E_1 \\
	& \vdots \\
	f_n & = & E_n
\end{eqnarray*}
όπου οποιαδήποτε συνάρτηση $f_i$ μπορεί να περιέχεται σε οποιοδήποτε $E_j$. Τώρα
πριν εφαρμόσουμε τον τελεστή $Y$ πρέπει να ενώσουμε όλες τις συναρτήσεις σε μία.
Αυτό μπορεί να γίνει με τις συναρτήσεις \en{TUPLE} $n$ και \en{INDEX} $k$. Η πρώτη
ενώνει $n$ όρους σε μια $n$-άδα και η δεύτερη επιστρέφει τον $k$-οστό όρο μιας $n$-άδας.
Και οι δύο μπορούν να υλοποιηθούν στον \la-λογισμό. Δημιουργούμε λοιπόν τον όρο
\[ f = \textrm{\en{TUPLE }} n\ f_i \ \dots\ f_n \]
και αντικαθιστούμε όλες τις εμφανίσεις των συναρτήσεων ως εξής
\[ f_i \rightarrow \textrm{\en{INDEX}}\ i\ f \]
Τέλος ο $f$ ορίζεται εφαρμόζοντας ένα τελεστή σταθερού σημείου
\[ f = Y\ (\lambda f.\textrm{\en{TUPLE }} n\ f_i \ \dots\ f_n ) \]

Οπως ήδη αναφέρθηκε ο \lci{} επιστρέπει τον ορισμό ψευδωνύμων που χρησιμοποιούν τον
εαυτό τους. Ο προκαθορισμένος τρόπος χειρισμού των ψευδωνύμων αυτών είναι αυτός που
αναφέρθηκε στην προηγούμενη παράγραφο. Επιπλέον παρέχεται η εντολή \kwd{FixedPoint}
η οποία αφαιρεί την αναδρομή από τα ψευδώνυμα χρησιμοποιώντας ένα \en{fixed point
combinator}. Η εντολή λειτουργεί ως εξής:
αρχικά δημιουργείται ένας γράφος στον οποίο κάθε κόμβος αντιστοιχεί σε ένα ψευδώνυμο.
Δυο κόβοι $S,T$ ενώνονται με μια κατευθυνόμενη ακμή αν το ψευδώνυμο $S$ περιέχει στον
ορισμό του το $Τ$. Οι κύκλοι στον γράφο αυτόν αντιστοιχούν σε αναδρομικούς όρους.
Η \kwd{FixedPoint} εντοπίζει τέτοιους κύκλους και, στην περίπτωση που περιέχουν
περισσότερους από ένα κόμβους, συνενώνει τα αντίστοιχα ψευδώνυμα σε ένα χρησιμοποιώντας
τις συναρτήσεις \en{TUPLE} και \en{INDEX}. Κατόπιν αφαιρεί την αναδρομή χρησιμοποιώντας
τον τελεστή $Y$ ο οποίος ορίζεται στο \kwd{.lcirc}.
Τα νέα ψευδώνυμα μπορούν να εμφανιστούν με την εντολή \kwd{ShowAlias}.

\section{Τελεστές}
Οι τελεστές είναι ένα ακόμα εργαλείο που συναντάται σχεδόν σε όλες τις γλώσσες
προγραμματισμού. Ο \lci{} υποστηρίζει τελεστές ως μια ειδική μορφή συναρτήσεως
που παίρνει δύο ορίσματα και συντακτικά εμφανίζεται ανάμεσα στα ορίσματά της. Ο
ορισμός ενός τελεστή απαιτεί δύο ενέργειες. Η πρώτη είναι η δήλωση του μαζί με
την προτεραιότητα και την προσεταιριστικότητά του, με τρόπο παρόμοιο με αυτόν
της \en{Prolog}. Αυτό γίνεται με την εντολή
\begin{center}
	\kwd{DefOp 'operator' preced assoc}
\end{center}
Τα εισαγωγικά είναι απαραίτητα για αναγνωριστεί ο όρος ως \en{id}. Η προτεραιότητα
(\en{precedence}) είναι ένας ακέραιος (0-255) και χρησιμοποιείται για την συντακτική
αναγνώριση σύνθετων εκφράσεων όταν δεν υπάρχουν παρενθέσεις. Η προσεταιριστικότητα
(\en{associativity}) παίρνει μία από τις ακόλουθες τιμές:
\begin{center}
	\begin{tabular}{cl}
		\kwd{yfx} & Αριστερά προσεταιριστικός τελεστής \\
		\kwd{xfy} & Δεξιά προσεταιριστικός τελεστής \\
		\kwd{xfx} & Μη προσεταιριστικός τελεστής
	\end{tabular}
\end{center}

To \kwd{x} αντιστοιχεί σε έναν όρο με μικρότερη προτεραιότητα από τον
τελεστή ενώ το \kwd{y} σε έναν με μικρότερη ή ίση. Έτσι η έκφραση \kwd{a+b+c*d}
θα ερμηνευτεί ως \kwd{(a+b)+(c*d)} διότι ο τελεστής \kwd{*} έχει μικρότερη προτεραιότητα
\footnote{O \lci{} ακολουθεί την λογική της \en{Prolog} δηλαδή εφαρμόζονται πρώτα οι
	τελεστές με μικρή προεταραιότητα.}
από τον \kwd{*} και ο \kwd{+} είναι αριστερά προσεταιριστικός. Οι όροι που δεν προκύπτουν
από εφαρμογή τελεστή ή εσωκλείονται σε παρενθέσεις θεωρείται ότι έχουν προτεραιότητα 0.
Επιπλέον η εφαρμογή θεωρείται ως τελεστής με προτεραιότητα 100 και αριστερή
προσεταιριστικότητα. Έτσι αν ο τελεστής \kwd{\$} οριστεί με προτεραιότητα 110 τότε
η έκφραση \kwd{a b\$c} ερμηνεύεται ως \kwd{(a b)\$c}.

Το δεύτερο βήμα είναι ο ορισμός του τελεστή ο οποίος γίνεται δηλώνοντας ένα ψευδώνυμο
με το ίδιο όνομα:
\begin{center}
	\kwd{'operator' = ...}
\end{center}
Η δήλωση βέβαια πρέπει να γίνει μέσα σε κάποιο αρχείο όπως όλες οι δηλώσεις ψευδωνύμων
ενώ τα εισαγωγικά είναι απαραίτητα για την αναγνώριση ως \en{id}. Κατά την συντακτική
ανάλυση ο \lci{} αντικαθιστά τους τελεστές με αναγνωριστικά, δηλαδή η
έκφραση \kwd{a+b} θα γίνει \kwd{'+' a b}. Το \kwd{'+'} είναι πλέον αναγνωριστικό και
όχι τελεστής και θα αντικατασταθεί κατά την εκτέλεση με τον αντίστοιχο όρο.

Στο αρχείο \kwd{.lcirc} ορίζονται οι συνιθισμένοι τελεστές για πράξεις με ακεραίους
και λίστες. Ορίζεται για παράδειγμα ο δεξιά προσεταιριστικός τελεστής \kwd{:}
που επιτρέπει την δήλωση λιστών ως \kwd{a:b:c:Nil}, ο τελεστής \kwd{++} για συνένωση
λιστών, ο \kwd{,} για τη δημιουργία ενός διατεταγμένου ζεύγους \kwd{(a,b)}, πράξεις
και συγκρίσεις ακεραίων κλπ.

\section{Στρατηγικές αποτίμισης}
Η στρατηγική αποτίμησης καθορίζει την επιλογή ενός \en{redex} όταν σε έναν όρο
υπάρχουν περισσότερα από ένα. Η στρατηγική που ακολουθεί ο \lci{} είναι αυτή της
αναγωγής κανονικής σειράς όπου επιλέγεται το αριστερότερο \en{redex} του όρου. Το
βασικό πλεονέκτημα της στρατηγικής αυτής είναι ότι πάντα οδηγεί στην κανονική μορφή,
αν αυτή υπάρχει. Έχει όμως και ένα βασικό μειονέκτημα το οποίο είναι ο πολλαπλός
υπολογισμός των όρων. Για παράδειγμα στην ακόλουθη αναγωγή
\begin{eqnarray*}
	&& (\lambda f.f(f\ y))((\lambda x.x)(\lambda x.x)) \\
	& \rightarrow & (\lambda x.x)(\lambda x.x)((\lambda x.x)(\lambda x.x)y) \\
	& \rightarrow & (\lambda x.x)((\lambda x.x)(\lambda x.x)y) \\
	& \rightarrow & (\lambda x.x)(\lambda x.x)y \\
	& \rightarrow & (\lambda x.x)y \\
	& \rightarrow & y
\end{eqnarray*}
ο όρος $(\lambda x.x)(\lambda x.x)$ υπολογίστηκε δύο φορές. Μια εναλλακτική στρατηγική
είναι η \en{call-by-value} στην οποία τα ορίσματα των συναρτήσεων υπολογίζονται πριν
την εκτέλεσή της. Έτσι μπορεί να αποφευχθεί ο πολλαπλός υπολογισμός.
\begin{eqnarray*}
	&& (\lambda f.f(f\ y))((\lambda x.x)(\lambda x.x)) \\
	& \rightarrow & (\lambda f.f(f\ y))(\lambda x.x) \\
	& \rightarrow & (\lambda x.x)((\lambda x.x)y) \\
	& \rightarrow & (\lambda x.x)y \\
	& \rightarrow & y
\end{eqnarray*}
Όμως η στρατηγική αυτή δεν εγγυάται την εύρεση της κανονικής μορφής. Επίσης υπάρχουν
και εναλλακτικές στρατηγικές όπως η \en{call-by-need} η οποία υλοποιείται στις
συναρτησιακές γλώσσες όπως η \en{Haskell}.

Στον \lci{} δεν έχει υλοποιηθεί κάποια τέτοια τεχνική αλλά έχει γίνει μια προσπάθεια
να ξεπεραστεί το πρόβλημα με την ακόλουθη μέθοδο. Έχει οριστεί ο τελεστής $\sim$ ο
οποίος έχει ειδική σημασία και δεν αντιμετωπίζεται όπως οι υπόλοιποι τελεστές. Η
έφραση $Μ\sim N$ ερμηνεύεται ως η εφαρμογή του $Μ$ στον $Ν$ για την οποία όμως
χρησιμοποιείται \en{call-by-value}. Δηλαδή αν ο όρος $Μ\ Ν$ είναι το αριστερότερο
\en{redex} τότε εκτελούνται πρώτα όλες οι μετατροπές του $Ν$ και έπειτα γίνεται
η εφαρμογή. Έτσι ο όρος $(\lambda f.f(f\ y))\sim((\lambda x.x)(\lambda x.x))$ θα
μετατραπεί με το δεύτερο από τους παραπάνω τρόπους. Ο τελεστής $\sim$ έχει την
ίδια προτεραιότητα και προσεταιριστικότητα με την εφαρμογή οπότε μπορεί εύκολα
να συνδυαστεί με αυτή.

Βέβαια ο τελεστής πρέπει να χρησιμοποιείται με \qm{σύνεση} καθώς η κανονική μορφή
του όρου $(\lambda x.y)\sim ((\lambda x.x\ x)(\lambda x.x\ x)$ αν και υπάρχει δεν
πρόκειται ποτέ να βρεθεί. Στο αρχείο \kwd{queens.lci} υπάρχει μια υλοποίηση του
προβλήματος των $n$-βασιλισσών στην οποία δοκιμαστικά χρησιμοποιείται ο τελεστής
αυτός. Χωρίς την χρήση του τελεστή το πρόγραμμα είναι αδύνατο να τερματίσει 
ακόμα και για τις 3 βασίλισσες όπου οι συνδυασμοί που πρέπει να ελεγχθούν είναι ελάχιστοι.
Αυτό οφείλεται στο γεγονός ότι οι όροι είναι αρκετά σύνθετοι και προκαλούν υπερβολικά
μεγάλο επαναυπολογισμό.
Χρησιμοποιώντας τον τελεστή $\sim$ και δοκιμάζοντας το πρόγραμμα σε έναν \en{Athlon 1800}
όλες οι λύσεις για τις 3 βασίλισσες βρέθηκαν σε 0.3 δευτερόλεπτα, για τις 4 σε 4.4 και
για τις 5 σε 190. Για τις 6 βασίλισσες σε δοκιμή αρκετών ωρών το πρόγραμμα δεν κατάφερε
να βρει λύση. Αυτό όμως δεν είναι ιδιαίτερα περίεργο δεδομένου ότι η \en{Haskell}
(με την ίδια υλοποίηση και χρησιμοποιώντας \en{lazy-evaluation} και αριθμητικές πράξεις
σταθερού χρόνου) χρειάζεται 1799705 \en{reductions} για τις 8 βασίλισσες και
υπερβολικά πολύ χρόνο για $n>12$.

\section{\en{Tracing}}
Το πρόγραμμα υποστηρίζει την βηματική εκτέλεση των μετατροπών (\en{trace}). Η λειτουργία
ενεργοποιείται με την εντολή
\begin{center}
	\kwd{Set trace on}
\end{center}
ή πατώντας \kwd{Ctrl-C} κατά την διάρκεια της εκτέλεσης. Εάν η λειτουργία είναι
ενεργοποιημένη τότε μετά από κάθε μετατροπή τυπώνεται ο τρέχον όρος και το
πρόγραμμα περιμένει είσοδο από το χρήστη. Οι διαθέσιμες εντολές είναι \kwd{step},
\kwd{continue} και \kwd{abort}. Η πρώτη εκτελεί το επόμενο βήμα, η
δεύτερη συνεχίζει τις μετατροπές χωρίς διακοπή ενώ η τρίτη διακόπτει την εκτέλεση.
Μια εναλλακτική λειτουργία είναι η εκτύπωση όλων των μετατροπών χωρίς όμως να
διακόπτεται η εκτέλεση, η οποία ενεργοποιείται με την εντολή
\begin{center}
	\kwd{Set showexec on}
\end{center}

\section{Εντολές συστήματος}
Ήδη σε προηγούμενες ενότητες αναφέρθηκαν διάφορες εντολές που υποστηρίζονται από
το πρόγραμμα. Οι εντολές αυτές είναι συναρτήσεις οι οποίες πιθανώς δέχονται ορίσματα.
Αν μια τέτοια συνάρτηση βρίσκεται αριστερά σε έναν όρο τότε δεν παράγεται η κανονική
μορφή του όρου αλλά εκτελείται μια εσωτερική λειτουργία του προγράμματος. Οι εντολές
αυτές περιγράφονται στον ακόλουθο πίνακα.
\begin{center}
\begin{tabular}{|l|p{200pt}|}
	\hline
	\textbf{Εντολή} & \textbf{Λειτουργία} \\
	\hline
	\kwd{FixedPoint} & Αφαιρεί την αναδρομή από τα ψευδώνυμα με τη χρήστη του
  		τελεστή σταθερού σημείου $Y$\\
	\kwd{DefOp op prec ass} & Ορίζει έναν τελεστή με τη δοθείσα προτεραιότητα και
		προσεταιριστικότητα. \\
	\kwd{ShowAlias [name]} & Εμφανίζει τον ορισμό του δοθέντος ψευδωνύμου ή λίστα
		με όλα τα ψευδώνυμα. \\
	\kwd{Print term} & Εκτυπώνει τον όρο. Χρήσιμο για τον έλεγχο της συντακτικής
		αναγνώρισης.\\
	\kwd{Consult file} & Ανάγνωση και επεξεργασία του αρχείου. \\
	\kwd{Set option on/off} & Αλλαγή κάποιας από τις ακόλουθες παραμέτρους του προγράμματος. \\
	\multicolumn{2}{|r|}{
		\begin{tabular}{|ll|}
			\hline
			\kwd{trace} & Βηματική εκτέλεση των μετατροπών \\
			\kwd{showexec} & Εκτύπωση όλων των μετατροπών \\
			\kwd{showpar} & Εμφάνιση όλων των παρενθέσεων ενός όρου \\
			\kwd{haskell} & Εμφάνιση των όρων με την μορφή της \en{Haskell} \\
			\kwd{readable} & Ευανάγνωστη εμφάνιση ακεραίων και λιστών \\
			\hline
		\end{tabular}
	} \\
	\kwd{Help} & Εμφάνιση μηνύματος βοήθειας. \\
	\kwd{Quit} & Τερματισμός του προγράμματος. \\
	\hline
\end{tabular}
\end{center}

\section{Παραδείγματα}
Ακολουθούν ορισμένα παραδείγματα χρήσης του προγράμματος.

\sen\begin{verbatim}
> 3+5*2
13

> Sum 1..10
55

> Take 10 (Nats 5)
[5, 6, 7, 8, 9, 10, 11, 12, 13, 14]

> Map (Add 3) 1..5
[4, 5, 6, 7, 8]

> Map (\n.n**2) 1..5
[\y.y, 4, 9, 16, 25]

> Filter (Leq 6) 3:6:10:11:Nil
[6, 10, 11]

> Length 1..10 ++ 4:5:Nil
12

> (Member 3 1..10) && (Length 3:4:5:Nil) >= 3
\x.\y.x
\end{verbatim}\sgr


Ο όρος \sen\verb+\y.y+\sgr{} είναι το 1 σε κανονική μορφή. Επιπλέον στο αρχείο \kwd{as2.lci}
έχουν υλοποιηθεί ορισμένες συναρτήσεις από την άσκηση 2 ενώ στο \kwd{queens.lci}
υπάρχει μια υλοποίηση του προβλήματος των $n$-βασιλισσών.

\sen\begin{verbatim}
> Consult 'queens.lci'
Successfully consulted queens.lci
> Queens 4
[[2, 4, \y.y, 3], [3, \y.y, 4, 2]]
\end{verbatim}\sgr

Όλες οι παραπάνω συναρτήσεις μπορούν να εκτελεστούν και με τη χρήση της εντολής
\kwd{FixedPoint} η οποία αφαιρεί την αναδρομή με τη χρήση του \en{fixed point combinator}
$Y$. Με την εντολή \kwd{ShowAlias} εμφανίζεται ο ορισμός των συναρτήσεων μετά την
εκτέλεση της εντολής.

\sen\begin{verbatim}
> FixedPoint
> ShowAlias Sum
Sum = Y _me.l.If (IsNil l) 0 (+ (Head l) (_me (Tail l)))
\end{verbatim}\sgr

\end{document}


