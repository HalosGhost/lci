
# .lcirc
# 
# Initialization file for lci program.
# This file declares basic functions and operators.


# Operator declaration. Must be in the form
#  ? DefOp 'oper' precedence associativity

? DefOp '~' 100 yfx;   # Enforces call-by-value (used internally)

? DefOp '!!' 90 yfx;   # List indexing (index origin: 1)

? DefOp '&&' 80 yfx;   # Logical and
? DefOp '||' 80 yfx;   # Logical or
? DefOp '^^' 80 yfx;   # Logical xor
? DefOp '~&' 80 yfx;   # Logical nand
? DefOp '~|' 80 yfx;   # Logical nor
? DefOp '~^' 80 yfx;   # Logical nxor

? DefOp '<'  70 xfx;   # Less than
? DefOp '<=' 70 xfx;   # Less or equal
? DefOp '==' 70 xfx;   # Equal
? DefOp '!=' 70 xfx;   # Not equal
? DefOp '>=' 70 xfx;   # Greater or equal
? DefOp '>'  70 xfx;   # Greater than

? DefOp '++' 60 xfy;   # Append lists
? DefOp ':'  60 xfy;   # Construct list (Head:Tail)

? DefOp ','  55 xfx;   # Construct ordered pair (a,b)
? DefOp '..' 55 xfx;   # n..m = [n,n+1,...,m] (or [n, n-1,...,m])

? DefOp '+'  50 yfx;   # Add
? DefOp '-'  50 yfx;   # Monus

? DefOp '*'  40 yfx;   # Multiply
? DefOp '/'  40 yfx;   # Integer division
? DefOp '%'  40 yfx;   # Integer modulus

? DefOp '**' 35 yfx;   # Exponential

# Operator definition.

'!!' = Index;

'&&' = And;
'||' = Or;
'^^' = Xor;
'~&' = Nand;
'~|' = Nor;
'~^' = Nxor;

'<' = LT;
'<=' = LE;
'==' = EQ;
'!=' = NE;
'>=' = GE;
'>' = GT;

'+' = Add;
'-' = Monus;
'*' = Multiply;
'/' = Divide;
'%' = Modulus;
'**' = Power;

':' = Cons;
'++' = Append;
',' = Pair;
'..' = Range;

# --- Combinatory Logic -----------------------------------------------

I = \x.x;
K = \x.\y.x;
S = \x.\y.\z.x z (y z);

B = \x.\y.\z.x (y z);
W = \x.\y.x y y;
C = \x.\y.\z.(x y) z;

U = \x.\y.y (x x y);

Omega = \x.x x;

Y = \f.(\x.f (x x)) (\x.f (x x));
Theta = U U;

Iota = \f.f S K;

# --- Miscellaneous Utilities -----------------------------------------

Flip = \f.\x.\y.f y x;
Compose = B;

# --- Logical functions -----------------------------------------------

True = K;
False = 0;
Not = \z.z False True;

And = \x.\y.x y x;
Or = \x.\y.x x y;
Xor = \x.\y.x (Not y) y;
Nand = \x.\y.Not (And x y);
Nor = \x.\y.Not (Or x y);
Nxor = \x.\y.Not (Xor x y);

# --- Control-Flow Sugar ----------------------------------------------

If = I;

Foldr = \f.\z.\l.l f z;
Foldl = \f.\z.\l.Foldr (\x.\g.\a.g (f a x)) (\x.x) l z;

Scanr = \f.\z.Foldr (\g.\a.(f g (Head a)) : a) (z : Nil);
Scanl = \f.\z.\l.Reverse (Foldr (\g.\a.(f g (Head a)) : a) (z : Nil) (Reverse l));

# --- Arithmetic functions --------------------------------------------

Succ = \n.\f.\x.n f (f x);
Pred = \x.\y.\z.x (\p.\q.q (p y)) (\y.z) I;

Add = \n.\m.\f.\x.n f (m f x);
Monus = \a.\b.b Pred a;

Multiply = Compose;
Divide = \n.\m.Length (TakeWhile (\i.i <= n) (Scanl '+' m (Replicate (Succ n - m) m)));
Modulus = \n.\m.n - (Last (TakeWhile (\i.i <= n) (Scanl '+' m (Replicate (Succ n - m) m))));

Power = \n.\m.m n;

Factorial = \n.Product ~ (2..n);

Min = \n.\m.(n < m) n m;
Max = \n.\m.(n > m) n m;

# --- Comparison functions / Predicates -------------------------------

IsZero = \n.n (\x.False) True;

LT = \a.\b.Not (GE a b);
LE = \a.\b.IsZero (Monus a b);
EQ = \a.\b.And (GE a b) (LE a b);
NE = \a.\b.Not (EQ a b);
GE = \a.\b.IsZero (Monus b a);
GT = \a.\b.Not (LE a b);

# --- Pairs -----------------------------------------------------------

Pair = \x.\y.\z.z x y;
Fst = \z.z True;
Snd = \z.z False;

## --- List construction -----------------------------------------------
#
#Cons = \x.\y.\s.s x y;
#Nil = \x.True;
#IsNil = \p.p \x.\y.False;
#Head = \p.p True;
#Tail = \p.p False;
#Range = \n.\m.(m-n) (\l.(Pred (Head l)):l) m:Nil;

# --- List Construction and Elimination -------------------------------

Cons  = \h.\t.\c.\n.c h (t c n);
Nil   = False;

IsNil = \p.p (\h.\t.False) True;

Head  = \p.p True False;
Tail  = \l.\c.\n.l (\h.\t.\g.g h (t c)) (\t.n) False;
Index = \l.\n.Head (Drop (Pred n) l);

Init  = \l.Reverse (Drop 1 (Reverse l));
Last  = Compose Head Reverse;

# --- Infinite recursion ----------------------------------------------

Loop = Loop;
Nats = \n.n:(Nats (Succ n));

# --- Ackermann function ----------------------------------------------

#using definition
Ack = \m.\n.
 If (IsZero m)
  n+1
  (If (IsZero n)
   (Ack m-1 1)
   (Ack m-1 ~(Ack m n-1))
  );

#using primitive recursion on high order function
Ack2 = \p.(p (\a.\q.(a (q a 1))) Succ);

# --- Mutually recursive functions ------------------------------------

Series = \n.
 If (IsZero n)
  0
  (G n);

G = \n.
 n + (Series n-1);

# --- Basic list functions --------------------------------------------

Append = Flip (Foldr ':');
Combine = \l.\r.Zip (Concat (Map (Replicate (Length l)) l)) (Concat (Replicate (Length r) r));
Concat = Foldr '++' Nil;
Copy = Foldr ':' Nil;
Drop = \n.n Tail;

Length = Foldr (\c.\n.n + 1) 0;
ListEq = \l.\r.((Length l) == (Length r)) (All (\p.(Fst p) == (Snd p)) (Zip l r)) False;
Member = \e.Any ('==' e);

Product = Foldl '*' 1;
Range = \n.\m.(n < m) (Scanl '+' n (Replicate (m - n) 1)) (Reverse (Scanl '+' m (Replicate (n - m) 1)));
Replicate = \n.\e.n (':' e) Nil;
Reverse = Foldl (Flip ':') Nil;
Sum = Foldl '+' 0;
 
Take = \n.\l.Reverse (Drop ((Length l) - n) (Reverse l));

Zip = Foldr (\x.\z.\l.(IsNil l) Nil ((x, (Head l)) : (z (Tail l)))) (\t.False);

# --- High order functions --------------------------------------------

All = \p.Foldr (Compose '&&' p) True;
Any = \p.Foldr (Compose '||' p) False;

Filter = \f.Foldr (\h.\t.((Compose (\p.p ':' Nil) f) h) h t) Nil;

Map = \f.Foldr (Compose ':' f) Nil;

TakeWhile = \f.Foldr ((\p.\x.\t.(p x) (x : t) Nil) f) Nil;
