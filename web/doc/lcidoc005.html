<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<META name="GENERATOR" content="hevea 1.09">
<LINK rel="stylesheet" type="text/css" href="lcidoc.css">
<TITLE>Recursion</TITLE>
</HEAD>
<BODY >
<A HREF="lcidoc004.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="lcidoc006.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H2 CLASS="section"><A NAME="htoc5">5</A>&#XA0;&#XA0;Recursion</H2><P>
Recursion is an essential programming tool provided by all serious programming
languages. <TT>lci</TT> supports two methods of implementing recursion: using
<EM>infinite temrs</EM> or using <EM>fixed point combinators</EM>.</P><H3 CLASS="subsection"><A NAME="toc1"></A><A NAME="htoc6">5.1</A>&#XA0;&#XA0;Recursion using infinite terms</H3><P>
<A NAME="par_recinf"></A>
If we allow an alias to contain itself then we can write terms like
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>M</I>&#XA0;=&#XA0;&#X3BB;&#XA0;<I>x</I>.<I>M</I>&#XA0;<I>y</I>&#XA0;</TD></TR>
</TABLE><P>
Replacing <I>M</I> according to this definition we get the term &#X3BB; <I>x</I>.(&#X3BB; <I>x</I>.<I>M</I> <I>x</I>) <I>x</I>
and if we keep on replacing we get the term
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X3BB;&#XA0;<I>x</I>.(&#X3BB;&#XA0;<I>x</I>.(&#X3BB;&#XA0;<I>x</I>.(...)&#XA0;<I>y</I>)&#XA0;<I>y</I>)&#XA0;<I>y</I>&#XA0;</TD></TR>
</TABLE><P>
Thus <I>M</I> can be considered as a term of infinite length. Of course this is not
a valid &#X3BB;-term, however it can be useful.</P><P>Now consider an arbitary closed &#X3BB;-term <I>M</I>, that is <I>FV</I>(<I>M</I>) = &#X2205;. We
can easily infer the following
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">	</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP>		<I>M</I>[<I>x</I>:=<I>N</I>]</TD><TD ALIGN=center NOWRAP>&#X2261;</TD><TD ALIGN=left NOWRAP><I>M</I>&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP>		(&#X3BB;&#XA0;<I>y</I>.<I>N</I>)[<I>x</I>:=<I>M</I>]</TD><TD ALIGN=center NOWRAP>&#X2261;</TD><TD ALIGN=left NOWRAP>&#X3BB;&#XA0;<I>y</I>.<I>N</I>[<I>x</I>:=<I>M</I>]&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP>		&#X3BB;&#XA0;<I>x</I>.<I>M</I>&#XA0;<I>x</I></TD><TD ALIGN=center NOWRAP>&#X2192;<SUB>&#X3B7;</SUB></TD><TD ALIGN=left NOWRAP><I>M</I></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
Thus variable substitution as well as &#X3B7;-reduction can be performed without
knowing the definition of M, that is without the need to replace it. So during
the evaluation of a term, <I>M</I> must be replaced only if we reach one of the
following terms:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">


&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;

</TD><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>	</TD><TD ALIGN=center NOWRAP>&#XA0;<I>M</I>&#XA0;<I>N</I>&#XA0;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=right NOWRAP>&#XA0;&#XA0;&#XA0;&#XA0;(1)</TD></TR>
<TR><TD ALIGN=right NOWRAP>	</TD><TD ALIGN=center NOWRAP>&#XA0;<I>M</I>
</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=right NOWRAP>&#XA0;&#XA0;&#XA0;&#XA0;(2)</TD></TR>
</TABLE></TD></TR>
</TABLE><P>If the first case <I>M</I> may contain an abstraction and in the second any redex.
If we replace an alias only when necessary, we can finish the evaluation without
performing all the replacements. For example the abstraction &#X3BB; <I>x</I>.<I>y</I> does
not use its argument, so the following reduction
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">(&#X3BB;&#XA0;<I>x</I>.<I>y</I>)&#XA0;<I>M</I>&#XA0;&#X2192;<SUB>&#X3B2;</SUB><I>y</I>&#XA0;</TD></TR>
</TABLE><P>
eliminates <I>M</I> without computing it.</P><P><TT>lci</TT> handles identifiers using this techique. That is it replaces an identifier
with it's corresponding term only when necessary and only once at a time. So even
if a term is recursive, it is possible to find a normal form if recursion is
interrupted by some condition. <TT>.lcirc</TT> contains many recursive definitions,
mainly concerning list manipulation functions.</P><P>This technique is not compatible with the pure calculus, as it uses invalid
&#X3BB;-terms. However the following must be noted: suppose that in term
<I>M</I> = &#X3BB; <I>x</I>.<I>M</I> <I>x</I> we need to replace <I>M</I> only twice until we reach it's normal
form. This means that in term  &#X3BB; <I>x</I>.(&#X3BB; <I>x</I>.(&#X3BB; <I>x</I>.<I>M</I> <I>y</I>) <I>y</I>) <I>y</I> 
no replacement will be performed. <I>M</I>. So we can substitute <I>M</I> with an arbitary
valid &#X3BB;-term <I>N</I> and we get
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>M</I>'&#XA0;=&#XA0;&#X3BB;&#XA0;<I>x</I>.(&#X3BB;&#XA0;<I>x</I>.(&#X3BB;&#XA0;<I>x</I>.<I>N</I>&#XA0;<I>y</I>)&#XA0;<I>y</I>)&#XA0;<I>y</I>&#XA0;</TD></TR>
</TABLE><P>
<I>M</I>' behaves exactly like <I>M</I> but it is a valid term. Of course in a different
situation more replacements could be needed, producing a different <I>M</I>'. So <I>M</I>
could be considered as a &#X201C;term generator&#X201D; that produces an appropriate <I>M</I>'
each time.</P><H3 CLASS="subsection"><A NAME="toc2"></A><A NAME="htoc7">5.2</A>&#XA0;&#XA0;Recursion using a fixed point combinator</H3><P>
<A NAME="par_recfp"></A>
Recursion can be implemented in pure &#X3BB;-calculus in a very sleek way, using a
fixed point combinator. A such combinator <I>Y</I> is a closed &#X3BB;-term that
satisfies the following relation
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>Y</I>&#XA0;<I>f</I>&#XA0;&#X2192;&#XA0;<I>f</I>&#XA0;(<I>Y</I>&#XA0;<I>f</I>)&#XA0;</TD></TR>
</TABLE><P>
for any term <I>f</I>. Now let <I>f</I> be a term that satisfies <I>f</I>=<I>E</I>, where <I>E</I> is
an expression that containts <I>f</I>. We convert <I>f</I> to a variable forming the
non-recursive term <I>F</I> = &#X3BB; <I>f</I>.<I>E</I>. It is easy to see that the function we seek
is a fixed point of F, that is <I>Y</I> <I>F</I>.</P><P>Things get a little bit more complicated if we have the following set of mutually
recursive terms
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP>	<I>f</I><SUB>1</SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>E</I><SUB>1</SUB>&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>	</TD><TD ALIGN=center NOWRAP>&#X22EE;&#XA0;</TD></TR>
<TR><TD ALIGN=right NOWRAP>	<I>f</I><SUB><I>n</I></SUB></TD><TD ALIGN=center NOWRAP>=</TD><TD ALIGN=left NOWRAP><I>E</I><SUB><I>n</I></SUB></TD></TR>
</TABLE></TD></TR>
</TABLE><P>
where any <I>f</I><SUB><I>i</I></SUB> can be contained in any <I>E</I><SUB><I>j</I></SUB>. Now, before applying <I>Y</I>, we must
join all terms in one. This can be done using the functions TUPLE <I>n</I> and INDEX <I>k</I>.
The former packages <I>n</I> terms into a <I>n</I>-tuple, the latter returns the <I>k</I>-th
element of a tuple. Both of them can be implemented in pure &#X3BB;-calculus. So we build
the following recursive term
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>&#XA0;=&#XA0;TUPLE &#XA0;<I>n</I>&#XA0;<I>f</I><SUB><I>i</I></SUB>&#XA0;&#XA0;&#X2026;&#XA0;<I>f</I><SUB><I>n</I></SUB>&#XA0;</TD></TR>
</TABLE><P>
and replace any occurences of terms <I>f</I><SUB><I>i</I></SUB> using INDEX <I>k</I>
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I><SUB><I>i</I></SUB>&#XA0;&#X2192;&#XA0;INDEX&#XA0;<I>i</I>&#XA0;<I>f</I>&#XA0;</TD></TR>
</TABLE><P>
Finally <I>f</I> is defined using a fixed point combinator
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>f</I>&#XA0;=&#XA0;<I>Y</I>&#XA0;(&#X3BB;&#XA0;<I>f</I>.TUPLE &#XA0;<I>n</I>&#XA0;<I>f</I><SUB><I>i</I></SUB>&#XA0;&#XA0;&#X2026;&#XA0;<I>f</I><SUB><I>n</I></SUB>&#XA0;)&#XA0;</TD></TR>
</TABLE><P>We have already mentioned that <TT>lci</TT> allows an alias to contain itself. The
default way of handling such aliases was described in paragraph <A HREF="#par_recinf">5.1</A>.
Moreover <TT>lci</TT> provides the command <TT>FixedPoint</TT> which removes circular references
from aliases using a fixed point combinator. Initially this command creates a
graph in which each vertex corresponds to an alias. Two vertexes <I>S</I>,<I>T</I> are connected
with a directed arc if alias <I>S</I> contains <I>T</I> in it's definition. A circle in
this graph denote a set of mutually recursive terms. <TT>FixedPoint</TT> detects such
circles and, in case they contain more than one arc, it packages the corresponding
terms using functions TUPLE and INDEX. Then it removes recursion using the combinator
<I>Y</I> which must be defined in <TT>.lcirc</TT>. The modified definition of recursive
aliases can be displayed using the <TT>ShowAlias</TT> command.</P><HR>
<A HREF="lcidoc004.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="index.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="lcidoc006.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
